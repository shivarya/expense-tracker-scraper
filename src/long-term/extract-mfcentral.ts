import fs from 'fs/promises';
import path from 'path';
import OpenAI from 'openai';
import dotenv from 'dotenv';
import { PDFParse } from 'pdf-parse';
import { fileURLToPath } from 'url';

dotenv.config();

const METADATA_FILE = path.join(process.cwd(), 'data', 'mfcentral-statement.json');
const OUTPUT_FILE = path.join(process.cwd(), 'data', 'mfcentral-raw.json');

async function parsePDF(buffer: Buffer): Promise<{ text: string; pages: number }> {
  const parser = new PDFParse({ data: buffer });
  try {
    const result = await parser.getText();
    return { text: result.text, pages: result.total };
  } finally {
    await parser.destroy();
  }
}

function buildPrompt(): string {
  return `You extract mutual fund holdings data from an Indian CAS (Consolidated Account Statement) PDF generated by MF Central.

Return ONLY valid JSON with this exact shape:
{
  "investor_name": "string",
  "pan": "string",
  "statement_date": "YYYY-MM-DD",
  "funds": [
    {
      "fund_name": "string (full scheme name as shown in the CAS)",
      "folio_number": "string",
      "amc": "string (AMC name, e.g. HDFC Mutual Fund)",
      "units": number,
      "nav": number,
      "invested_amount": number,
      "current_value": number,
      "plan_type": "direct|regular",
      "option_type": "growth|idcw|dividend"
    }
  ]
}

Rules:
1. Extract EVERY scheme/folio combination. Each unique folio + scheme is a separate entry.
2. "units" = closing/available unit balance for that scheme (the final balance, NOT transaction units).
3. "nav" = latest NAV shown for the scheme. Use 0 if not found.
4. "invested_amount" = cost value / total purchase cost for the scheme. Use 0 if not found.
5. "current_value" = market value / valuation at current NAV. If only units and NAV are available, compute units √ó NAV.
6. Detect plan_type from scheme name: if it contains "Direct" ‚Üí "direct", otherwise "regular".
7. Detect option_type from scheme name: "Growth" ‚Üí "growth", "IDCW" or "Dividend" ‚Üí "idcw", default "growth".
8. SKIP schemes with 0 units (fully redeemed). Only include holdings with units > 0.
9. Clean up folio numbers: remove any trailing text like "/ KFintech" or "/ CAMS" ‚Äî keep only the numeric folio.
10. For AMC name, use the clean AMC name without "Mutual Fund" suffix duplication.
11. Use 0 for any missing numeric values.
12. Do NOT wrap your response in markdown code fences.`;
}

async function extractWithAI(pdfText: string, filename: string): Promise<any> {
  const isAzure = !!process.env.AZURE_OPENAI_ENDPOINT;

  const openai = new OpenAI(
    isAzure
      ? {
          apiKey: process.env.AZURE_OPENAI_API_KEY,
          baseURL: process.env.AZURE_OPENAI_ENDPOINT,
        }
      : {
          apiKey: process.env.OPENAI_API_KEY,
        }
  );

  const model = isAzure
    ? process.env.AZURE_OPENAI_DEPLOYMENT!
    : (process.env.OPENAI_MODEL || 'gpt-4-turbo');

  const systemPrompt = buildPrompt();

  // CAS PDFs can be very long with transaction history ‚Äî send enough text for AI to parse
  // but cap at a reasonable token limit
  const maxChars = 80000;
  const userPrompt = `File: ${filename}\n\nExtract all mutual fund holdings from this CAS statement:\n\n${pdfText.substring(0, maxChars)}`;

  console.log(`ü§ñ Sending ${Math.min(pdfText.length, maxChars).toLocaleString()} chars to AI (model: ${model})...`);

  const response = await openai.chat.completions.create({
    model,
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt },
    ],
    temperature: 0,
    max_completion_tokens: 16000,
  });

  const content = response.choices[0].message.content?.trim() || '{}';

  // Strip potential markdown code fences
  const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
  const jsonStr = jsonMatch ? jsonMatch[1] : content;

  try {
    return JSON.parse(jsonStr);
  } catch (parseError) {
    console.error('‚ùå Failed to parse AI response as JSON. Raw response:');
    console.error(content.substring(0, 500));
    throw new Error('AI returned invalid JSON');
  }
}

async function extractMfcentral() {
  console.log('üöÄ Extracting MF Central CAS statement\n');
  console.log('‚îÅ'.repeat(60));

  // Read metadata to find the PDF path
  let metadata: any;
  try {
    const raw = await fs.readFile(METADATA_FILE, 'utf-8');
    metadata = JSON.parse(raw);
  } catch {
    throw new Error('Metadata file not found. Run mfc:fetch first to download the CAS PDF.');
  }

  const pdfPath = metadata.pdfPath;
  if (!pdfPath) {
    throw new Error('No pdfPath in metadata. Run mfc:fetch first.');
  }

  // Check PDF exists
  try {
    await fs.access(pdfPath);
  } catch {
    throw new Error(`PDF not found at: ${pdfPath}`);
  }

  const filename = path.basename(pdfPath);
  console.log(`üìÑ Processing: ${filename}`);

  // Read and parse PDF
  const pdfBuffer = await fs.readFile(pdfPath);
  let pdfText = '';

  try {
    const result = await parsePDF(pdfBuffer);
    pdfText = result.text;
    console.log(`‚úÖ Parsed ${result.pages} page(s), ${pdfText.length.toLocaleString()} characters`);
  } catch (pdfError: any) {
    // CAS PDFs from MF Central may be password-protected (typically PAN + DOB)
    if (pdfError.message?.includes('Encrypted') || pdfError.message?.includes('password')) {
      console.log('üîí PDF is encrypted ‚Äî trying configured passwords...');

      let pdfPasswords: string[] = [];
      try {
        const passwordsPath = path.join(process.cwd(), 'src', 'config', 'pdf-passwords.json');
        const passwordsData = await fs.readFile(passwordsPath, 'utf-8');
        pdfPasswords = JSON.parse(passwordsData);
      } catch {
        pdfPasswords = [];
      }

      if (pdfPasswords.length === 0) {
        throw new Error(
          'PDF is password-protected. Add passwords to src/config/pdf-passwords.json (typically PAN + DOB format like ABCDE1234F01011990)'
        );
      }

      const { decrypt } = await import('node-qpdf2');
      const decryptedPath = pdfPath.replace('.pdf', '_decrypted.pdf');
      let decrypted = false;

      for (const pwd of pdfPasswords) {
        try {
          await decrypt({ input: pdfPath, output: decryptedPath, password: pwd });
          const decryptedData = await fs.readFile(decryptedPath);
          const result = await parsePDF(decryptedData);
          pdfText = result.text;
          await fs.unlink(decryptedPath).catch(() => {});
          decrypted = true;
          console.log('‚úÖ Decrypted and parsed successfully');
          break;
        } catch {
          continue;
        }
      }

      if (!decrypted) {
        await fs.unlink(decryptedPath).catch(() => {});
        throw new Error('Unable to decrypt CAS PDF with configured passwords');
      }
    } else {
      throw pdfError;
    }
  }

  if (!pdfText || pdfText.length < 100) {
    throw new Error('PDF text is too short ‚Äî the file may be corrupt or image-based');
  }

  // Extract with AI
  console.log('ü§ñ Extracting mutual fund holdings with AI...');
  const parsed = await extractWithAI(pdfText, filename);

  const funds = parsed.funds || [];

  // Validate and clean
  const validFunds = funds.filter((f: any) => {
    if (!f.fund_name || !f.folio_number) return false;
    if (Number(f.units) <= 0) return false;
    return true;
  });

  const output = {
    extractedAt: new Date().toISOString(),
    source: 'MF Central CAS',
    sourceFile: filename,
    pdfPath: pdfPath,
    period: metadata.period || 'unknown',
    investor_name: parsed.investor_name || '',
    pan: parsed.pan || '',
    statement_date: parsed.statement_date || '',
    totalSchemes: validFunds.length,
    funds: validFunds.map((f: any) => ({
      fund_name: String(f.fund_name).trim(),
      folio_number: String(f.folio_number).trim().replace(/\s*\/\s*(CAMS|KFintech|Karvy|Franklin).*$/i, ''),
      amc: String(f.amc || '').trim(),
      units: Number(f.units || 0),
      nav: Number(f.nav || 0),
      invested_amount: Number(f.invested_amount || 0),
      current_value: Number(f.current_value || 0),
      plan_type: ['direct', 'regular'].includes(String(f.plan_type).toLowerCase())
        ? String(f.plan_type).toLowerCase()
        : 'direct',
      option_type: ['growth', 'idcw', 'dividend'].includes(String(f.option_type).toLowerCase())
        ? String(f.option_type).toLowerCase() === 'dividend' ? 'idcw' : String(f.option_type).toLowerCase()
        : 'growth',
    })),
  };

  await fs.writeFile(OUTPUT_FILE, JSON.stringify(output, null, 2));

  // Print summary
  console.log(`\n‚úÖ Extracted ${output.totalSchemes} mutual fund scheme(s)`);
  console.log(`   Investor: ${output.investor_name}`);
  console.log(`   PAN: ${output.pan}`);

  const totalInvested = output.funds.reduce((s: number, f: any) => s + f.invested_amount, 0);
  const totalCurrent = output.funds.reduce((s: number, f: any) => s + f.current_value, 0);
  console.log(`   Total Invested: ‚Çπ${totalInvested.toLocaleString('en-IN')}`);
  console.log(`   Total Current:  ‚Çπ${totalCurrent.toLocaleString('en-IN')}`);
  console.log(`   Gain/Loss:      ‚Çπ${(totalCurrent - totalInvested).toLocaleString('en-IN')}`);

  console.log(`\nüíæ Saved: ${OUTPUT_FILE}`);
}

const isDirectRun = !!process.argv[1] && fileURLToPath(import.meta.url) === path.resolve(process.argv[1]);
if (isDirectRun) {
  extractMfcentral().catch((error: any) => {
    console.error('\n‚ùå Error:', error.message || error);
    process.exit(1);
  });
}
